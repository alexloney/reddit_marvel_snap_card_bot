import datetime
import logging
import argparse
import os
import sys
import time

from database import Database, Card
from reddit_connect import RedditConnect
from comments import CommentParser
import utils

logging.basicConfig(
    format='%(asctime)s %(levelname)-8s %(message)s',
    level=logging.INFO)
logging.captureWarnings(True)

class SnapBot:
    def __init__(self, subreddit, config_file, db_update_timeout,
                 max_fuzzy_distance, exact_match_threshold, dry_run, debug,
                 client_id, client_secret, user_agent, reddit_username, reddit_password):
        self.subreddit = subreddit
        self.config_file = config_file
        self.db_update_timeout = db_update_timeout
        self.max_fuzzy_distance = max_fuzzy_distance
        self.exact_match_threshold = exact_match_threshold
        self.dry_run = dry_run
        self.debug = debug
        self.client_id = client_id
        self.client_secret = client_secret
        self.user_agent = user_agent
        self.reddit_username = reddit_username
        self.reddit_password = reddit_password

        self.database = Database(config_file)
        self.comment_parser = CommentParser(max_fuzzy_distance, exact_match_threshold)
        self.reddit_connect = RedditConnect(client_id, client_secret, user_agent, reddit_username, reddit_password)

    def run(self):
        logging.info('Starting Reddit bot')
        try:
            for comment in self.reddit_connect.stream_comments(self.subreddit):
                card_name = self.comment_parser.parse_comment(comment.body)
                if card_name:
                    card_info = self.database.get_card_info(card_name)
                    if card_info:
                        response = f"Found information about {card_name}:\n{card_info}"
                    else:
                        response = f"No information found for {card_name}."
                    # Construct the GitHub issue link with pre-filled body
                    github_link = self._construct_github_issue_link(comment.url)
                    response += f"\n\nIf you have any issues, please report them here: {github_link}"
                    self.respond_to_comment(comment, response)
        except Exception as e:
            logging.error(f'An error occurred: {e}')

    def respond_to_comment(self, comment, response):
        try:
            if not self.dry_run:
                self.reddit_connect.reply_to_comment(comment, response)
            logging.info(f'Replied to comment {comment.id} with: {response}')
        except Exception as e:
            logging.error(f'Error responding to comment {comment.id}: {e}')

    def _construct_github_issue_link(self, reddit_url):
        """
        Constructs a GitHub issue link with a pre-filled body containing the Reddit comment URL.

        :param reddit_url: The URL of the Reddit comment.
        :return: A string representing the GitHub issue link.
        """
        base_github_url = "https://github.com/your-repo/your-project/issues/new"
        if not reddit_url:
            logging.warning("Reddit URL is missing, cannot construct GitHub issue link.")
            return base_github_url
        encoded_reddit_url = utils.url_encode(reddit_url)
        return f"{base_github_url}?body=Please%20include%20details%20about%20the%20issue.%20Reddit%20comment:%20{encoded_reddit_url}"

if __name__ == "__main__":
    # Parse command line arguments
    parser = argparse.ArgumentParser(description='Reddit bot for Marvel Snap card information.')
    parser.add_argument('--subreddit', type=str, help='Subreddit to monitor')
    parser.add_argument('--config-file', type=str, help='Path to the configuration file')
    parser.add_argument('--db-timeout', type=int, help='Timeout for database updates in seconds')
    parser.add_argument('--max-fuzzy-distance', type=int, help='Maximum Levenshtein distance for fuzzy matching')
    parser.add_argument('--exact-match-threshold', type=int, help='Threshold for considering an exact match')
    parser.add_argument('--dry-run', action='store_true', help='Flag to indicate if it\'s a dry run')
    parser.add_argument('--debug', action='store_true', help='Enable debugging')
    parser.add_argument('--client-id', type=str, help='Reddit API client ID')
    parser.add_argument('--client-secret', type=str, help='Reddit API client secret')
    parser.add_argument('--user-agent', type=str, help='User agent string for Reddit API requests')
    parser.add_argument('--reddit-username', type=str, help='Reddit username')
    parser.add_argument('--reddit-password', type=str, help='Reddit password')

    args = parser.parse_args()

    # Initialize and run the bot
    bot = SnapBot(
        subreddit=args.subreddit,
        config_file=args.config_file,
        db_update_timeout=args.db_timeout,
        max_fuzzy_distance=args.max_fuzzy_distance,
        exact_match_threshold=args.exact_match_threshold,
        dry_run=args.dry_run,
        debug=args.debug,
        client_id=args.client_id,
        client_secret=args.client_secret,
        user_agent=args.user_agent,
        reddit_username=args.reddit_username,
        reddit_password=args.reddit_password
    )
    bot.run()