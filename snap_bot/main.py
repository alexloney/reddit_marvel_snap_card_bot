#!python

import datetime
import logging
import argparse
import os
import sys
import time

from database import Database, Card
from reddit_connect import RedditConnect
from comments import CommentParser
import utils

logging.basicConfig(
    format='%(asctime)s %(levelname)-8s %(message)s',
    level=logging.INFO)
logging.captureWarnings(True)

class SnapBot:
    def __init__(self, subreddit, config_file, db_update_timeout,
                 max_fuzzy_distance, exact_match_threshold, dry_run, debug,
                 client_id, client_secret, user_agent, reddit_username, reddit_password):
        self.subreddit = subreddit
        self.config_file = config_file
        self.db_update_timeout = db_update_timeout
        self.max_fuzzy_distance = max_fuzzy_distance
        self.exact_match_threshold = exact_match_threshold
        self.dry_run = dry_run
        self.debug = debug
        self.client_id = client_id
        self.client_secret = client_secret
        self.user_agent = user_agent
        self.reddit_username = reddit_username
        self.reddit_password = reddit_password

        self.database = Database(max_fuzzy_distance, exact_match_threshold)
        self.comment_parser = CommentParser()
        self.reddit_connect = RedditConnect(subreddit)

    def run(self):
        logging.info('Starting Reddit bot')
        try:
            while True:

                # Check the current date/time and compare it to the last time the
                # card lookup database has been updated. If it exceeds our set timeout
                # interval, update our internal card lookup database and reset our
                # last time we updated.
                current_time = datetime.datetime.now()
                if (current_time - self.last_database_update).total_seconds() > self.db_update_timeout:
                    logging.info('Reloading card lookup database')
                    self.database.update_card_database()
                    self.last_database_update = datetime.datetime.now()

                # Fetch the next set of comments
                for comment in self.reddit_connect.get_comments_shallow():

                    # Prevent replying to my own comments, if the author of the
                    # comment is the bot itself, then simply ignore the comment
                    if self.reddit_connect.get_my_username() == comment.author or \
                        'MarvelSnapCardBot' == comment.author:
                        continue

                    # Parse the comment and fetch the card names from it
                    parser = CommentParser(comment)
                    card_names = parser.parse()

                    # Match all of the cards then remove duplicates
                    matched_cards = []
                    for name in card_names:
                        for item in self.database.search(name):
                            matched_cards.append(item)
                    unique_cards = utils.remove_duplicate_cards(matched_cards)

                    # Resolve all tokens to their base cards if possible
                    unique_cards = utils.resolve_tokens_to_base(self.database, unique_cards)
                    
                    # Resolving tokens to cards could add duplicate cards, since a
                    # card like Snowguard or Nico call their summon cards the same
                    # as the base card. This could result in duplicating cards and
                    # causing a much larger output than expected. Removing
                    # duplicates here before we expand back into tokens will resolve
                    # this issue.
                    unique_cards = utils.remove_duplicate_cards(unique_cards)

                    # Now reverse the above and resolve all tokens from all base cards
                    unique_cards = utils.insert_tokens_from_cards(self.database, unique_cards)

                    # Combine all of the cards from above together into a single
                    # output message
                    response = ''
                    for name in unique_cards:
                        response += str(name)
                    
                    # If our response has a length, this means we identified a card
                    # request and correctly matched it to a card to reply with. If
                    # that is the case, we may proceed with the request
                    if len(response) > 0:
                        github_url = f"https://github.com/alexloney/reddit_marvel_snap_card_bot/issues/new?body=Detected%20comment:%20{comment.url}%0A%0ACard%20request:%20{response}"
                        response += f"*Message generated by {self.reddit_connect.get_my_username()}. Use syntax [[card_name]] to get a reply like this. Report any issues on [github]({github_url}).*"

                        logging.info('Detected comment: ' + comment.url)
                        
                        # Obtaining the authors is a more expensive operation, so we
                        # only do this at the very end before we submit the reply.
                        # In this case, we obtain the author names and verify that
                        # our username is not in a reply to this comment. This is to
                        # prevent us from replying to the same comment multiple times
                        authors = self.reddit_connect.get_comment_reply_author_names(comment.id)
                        if self.reddit_connect.get_my_username() not in authors and \
                            'MarvelSnapCardBot' not in authors:
                            logging.info('Replying to comment: ' + comment.url)
                            if not self.dry_run:
                                self.reddit_connect.reply_to_comment(comment, response)
                        else:
                            logging.info('Already replied to this comment, skipping.')

        except KeyboardInterrupt:
            logging.info('Shutting down Reddit bot')