#! /usr/bin/env python3

import datetime
import sys
import urllib.parse
import logging

from database import Database
from reddit_connect import RedditConnect
from comment_parser import CommentParser
import utils


def main():
    logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

    subreddit = ''
    config_file = ''
    db_update_timeout = 3600  # Default timeout for database update in seconds
    max_fuzzing_distance = 2
    exact_match_threshold = 5
    dry_run = False
    debug = False

    client_id = ''
    client_secret = ''
    user_agent = ''
    reddit_username = ''
    reddit_password = ''

    # Parse command line arguments or configuration file here if needed
    # For simplicity, we assume all necessary variables are set above

    logging.info('Subreddit: ' + subreddit)
    logging.info('Config File: ' + config_file)
    logging.info('DB Update Timeout: ' + str(db_update_timeout))
    logging.info('Max Fuzzing Distance: ' + str(max_fuzzing_distance))
    logging.info('Exact Match Threshold: ' + str(exact_match_threshold))
    logging.info('Dry Run: ' + str(dry_run))
    logging.info('Debug: ' + str(debug))
    logging.info('Client ID: ' + client_id)
    logging.info('User Agent: ' + user_agent)
    logging.info('Reddit Username: ' + reddit_username)

    if debug:
        logging.getLogger("").setLevel(logging.DEBUG)
        logging.debug('Debug logging enabled')

    if len(config_file) == 0 and \
       (len(client_id) == 0 or \
        len(client_secret) == 0 or \
        len(user_agent) == 0 or \
        len(reddit_username) == 0 or \
        len(reddit_password) == 0):
        print('Error: Either a config file, or all config details must be provided')
        sys.exit(1)
    
    if len(subreddit) == 0:
        print('Error: You must provide a subreddit to monitor')
        sys.exit(1)

    database = Database(max_fuzzing_distance, exact_match_threshold)

    # Perform our initial database update to get the first version of our card
    # lookups
    logging.info('Loading card lookup database')
    try:
        database.update_card_database()
    except Exception as e:
        logging.error(f'Failed to update card database: {e}')
        sys.exit(1)
    last_database_update = datetime.datetime.now()
    logging.info('Next DB update in ' + str(db_update_timeout) + 's')

    logging.info('Establishing Reddit connection (' + subreddit + ')')
    if len(config_file) > 0:
        logging.info('Using Reddit config file')
        reddit_connect = RedditConnect(subreddit)
        try:
            reddit_connect.init_reddit_config(config_file)
        except Exception as e:
            logging.error(f'Failed to initialize Reddit with config file: {e}')
            sys.exit(1)
    else:
        logging.info('Using supplied id/secret/agent/user/pass')
        reddit_connect = RedditConnect(subreddit)
        try:
            reddit_connect.init_reddit(client_id, client_secret, user_agent, username=reddit_username, password=reddit_password)
        except Exception as e:
            logging.error(f'Failed to initialize Reddit with provided credentials: {e}')
            sys.exit(1)

    try:
        while True:
            for comment in reddit_connect.get_comments():
                card_names = CommentParser.parse(comment.body)
                if not card_names:
                    continue

                unique_cards = set()
                for name in card_names:
                    base_cards = database.get_base_cards(name)
                    unique_cards.update(base_cards)
                    unique_cards.update(database.get_tokens_from_cards(base_cards))

                response = '\n'.join(unique_cards)

                if response:
                    github_repo_url = 'https://github.com/your-repo/your-project'
                    issue_report_url = f'{github_repo_url}/issues/new?body=Issue%20detected%20on%20comment:%20{urllib.parse.quote(comment.url)}'
                    response += f'\n*Message generated by {reddit_connect.get_my_username()}. Use syntax [[card_name]] to get a reply like this. Report any issues on [github]({issue_report_url})*'

                    logging.info('Detected comment: ' + comment.url)
                    
                    # Obtaining the authors is a more expensive operation, so we
                    # only do this at the very end before we submit the reply.
                    # In this case, we obtain the author names and verify that
                    # our username is not in a reply to this comment. This is to
                    # prevent us from replying to the same comment multiple times
                    try:
                        authors = reddit_connect.get_comment_reply_author_names(comment.id)
                    except Exception as e:
                        logging.error(f'Failed to get comment reply author names: {e}')
                        continue

                    if reddit_connect.get_my_username() not in authors and \
                        'MarvelSnapCardBot' not in authors:
                        logging.info('Submitting reply')
                        logging.debug(response)
                        if dry_run == False:
                            try:
                                reddit_connect.add_reply(comment.id, response)
                            except Exception as e:
                                logging.error(f'Failed to submit reply: {e}')
                    else:
                        logging.info('Ignoring comment, bot reply detected')

            # Check for database update timeout
            current_time = datetime.datetime.now()
            if (current_time - last_database_update).total_seconds() > db_update_timeout:
                logging.info('Updating card lookup database')
                try:
                    database.update_card_database()
                except Exception as e:
                    logging.error(f'Failed to update card database: {e}')
                last_database_update = current_time

    except KeyboardInterrupt:
        pass


if __name__ == '__main__':
    main()